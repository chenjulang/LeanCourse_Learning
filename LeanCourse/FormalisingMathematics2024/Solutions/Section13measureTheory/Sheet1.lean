/-
Copyright (c) 2023 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author : Kevin Buzzard
-/
import Mathlib.Tactic
-- imports all the Lean tactics
import Mathlib.MeasureTheory.MeasurableSpace.Defs

/-

# Measure theory

## Sigma algebras.

A σ-algebra on a type `X` is a collection of subsets of `X` satisfying some
axioms, and in Lean you write it like this:

-/

namespace Section13Sheet1Solutions

-- let X be a set
variable (X : Type)

-- ...and let 𝓐 be a sigma-algebra on X
variable (𝓐 : MeasurableSpace X)

/-

Note that `MeasurableSpace` is a *class*, so really we should be writing `[MeasurableSpace X]`,
meaning "let `X` be equipped once and for all with a sigma algebra which we won't give a name to".
But in this sheet we'll consider making them explicitly.

Let's do the following exercise. Show that if `A` is a subset of `X` then `{0,A,Aᶜ,X}`
is a sigma algebra on `X`.

-/
def genBy (A : Set X) : MeasurableSpace X where
  MeasurableSet' S := S = ∅ ∨ S = A ∨ S = Aᶜ ∨ S = ⊤
  measurableSet_empty := by left; rfl
  measurableSet_compl := by
    rintro s (h | h | h | h)
    · right; right; right; simp [h]
    · right; right; left; rw [h]
    · right; left; rw [h]; simp
    · left; rw [h]; simp
  measurableSet_iUnion := by
    intro f hf
    by_cases h1 : ∃ j, f j = ⊤
    · right; right; right
      rw [eq_top_iff]
      rintro x -
      rw [Set.mem_iUnion]
      cases' h1 with j hj
      use j
      rw [hj]
      triv
    push_neg at h1
    by_cases h2 : ∃ j k, f j = A ∧ f k = Aᶜ
    · right; right; right; rw [eq_top_iff]; rintro x -
      rw [Set.mem_iUnion]
      rcases h2 with ⟨j, k, hj, hk⟩
      by_cases hxA : x ∈ A
      · use j
        rwa [hj]
      · use k
        rwa [hk]
    push_neg at h2
    by_cases h3 : ∃ j, f j = A
    · right; left
      ext x
      rw [Set.mem_iUnion]
      cases' h3 with j hj
      constructor
      · rintro ⟨i, hi⟩
        suffices f i ⊆ A by exact this hi
        rcases hf i with (h | h | h | h)
        · rw [h]; simp
        · rw [h]
        · cases h2 j i hj h
        · cases h1 i h
      · intro hx
        use j
        rwa [hj]
    by_cases h4 : ∃ j, f j = Aᶜ
    · right; right; left
      ext x
      rw [Set.mem_iUnion]
      cases' h4 with j hj
      constructor
      · rintro ⟨i, hi⟩
        suffices f i ⊆ Aᶜ by exact this hi
        rcases hf i with (h | h | h | h)
        · rw [h]; simp
        · cases h2 i j h hj
        · rw [h]
        · cases h1 i h
      · intro hx
        use j
        rwa [hj]
    push_neg at h3 h4
    left
    apply Set.eq_empty_of_subset_empty
    intro x hx
    rw [Set.mem_iUnion] at hx
    cases' hx with i hi
    rcases hf i with (h | h | h | h)
    · rwa [h] at hi
    · cases h3 _ h
    · cases h4 _ h
    · cases h1 _ h

-- An alternative approach to defining the sigma algebra generated by `{A}` is just
-- to use `MeasurableSpace.generateFrom`:
example (A : Set X) : MeasurableSpace X :=
  MeasurableSpace.generateFrom {A}

-- But the problem with that approach is that you don't get the actual sets
-- in the sigma algebra for free. Try this, to see what I mean!
example (A : Set X) :
    (MeasurableSpace.generateFrom {A}).MeasurableSet' =
    ({∅, A, Aᶜ, ⊤} : Set (Set X)) := by
  ext B
  change MeasurableSpace.GenerateMeasurable _ B ↔
    B ∈ ({∅, A, Aᶜ, ⊤} : Set (Set X))
  simp only [Set.top_eq_univ, Set.mem_insert_iff, Set.mem_singleton_iff]
  fconstructor
  · intro h
    induction' h with A' hA' C hC1 hC2 f hf1 hf2
    · aesop
    · aesop
    · aesop
    · exact (genBy X A).measurableSet_iUnion f hf2
  · rintro (rfl | rfl | rfl | rfl)
    · apply MeasurableSpace.GenerateMeasurable.empty
    · apply MeasurableSpace.GenerateMeasurable.basic; simp
    · apply MeasurableSpace.GenerateMeasurable.compl;
      apply MeasurableSpace.GenerateMeasurable.basic; simp
    · rw [show (Set.univ : Set X) = ∅ᶜ by simp]
      apply MeasurableSpace.GenerateMeasurable.compl
      apply MeasurableSpace.GenerateMeasurable.empty

end Section13Sheet1Solutions
